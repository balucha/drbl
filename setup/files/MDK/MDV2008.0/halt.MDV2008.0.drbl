#!/bin/bash
#
# halt          This file is executed by init when it goes into runlevel
#               0 (halt) or runlevel 6 (reboot). It kills all processes,
#               unmounts file systems and then either halts or reboots.
#
# Author:       Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
#               Modified for RHS Linux by Damien Neil
#
# Modified by Steven Shiau <steven _at_ nchc org tw> to use in DRBL for Mandiva 2007.1 on 2007/May/7

NOLOCALE=1
. /etc/init.d/functions

action() {
   echo -n "$1 "
   shift
   if [ "$BOOTUP" = "color" ]; then
      "$@" && echo_success || echo_failure
   else
      "$@"
   fi
   echo
}

halt_crypto() {
    fnval=0
    while read dst src key; do
	[ -z "$dst" -o "${dst#\#}" != "$dst" ] && continue
        if [ -b "/dev/mapper/$dst" ]; then
            if /sbin/dmsetup info "$dst" | grep -q '^Open count: *0$'; then
                /sbin/cryptsetup remove "$dst"
            else
                fnval=1
            fi
        fi
    done < /etc/crypttab
    return $fnval
}

# See how we were called.
case "$0" in
   *halt)
	message=`gprintf "Halting system..."`
	command="/sbin/halt"
	;;
   *reboot)
	message=`gprintf "Please stand by while rebooting the system..."`
	command="/sbin/reboot"
	kexec_command="/sbin/kexec"
	;;
   *)
	gprintf "%s: call me as 'halt' or 'reboot' please!\n" $0
	exit 1
	;;
esac

case "$1" in
   *start)
   	;;
   *)
	gprintf "Usage: %s\n" "$(basename $0) {start}"
	exit 1
	;;
esac

# Recreate the /initrd if needed
if [ ! -d /initrd ]; then
    action "Creating initrd directory" mkdir /initrd
fi
# DRBL, because it's DRBL, forget about this, START
#if [ -d /initrd -a ! -f /initrd/README.WARNING ]; then
#    cat > /initrd/README.WARNING <<EOF
#(mkinitrd) Don't remove this directory, it's needed at boot time,
#in the initrd, to perform the pivot_root.
#EOF
#fi
# DRBL, because it's DRBL, forget about this, END

# Kill all processes.
[ "${BASH+bash}" = bash ] && enable kill

action "Sending all processes the TERM signal..." /sbin/killall5 -15
# DRBL, because it's DRBL, no waiting for sleep... comment sleep
#sleep 5
action "Sending all processes the KILL signal..."  /sbin/killall5 -9

# Write to wtmp file before unmounting /var
/sbin/halt -w

# Save random seed
touch /var/lib/random-seed
chmod 600 /var/lib/random-seed
action "Saving random seed: " dd if=/dev/urandom of=/var/lib/random-seed count=1 bs=512 2>/dev/null

# Sync the system clock.
ARC=0
SRM=0
UTC=0

if [ -f /etc/sysconfig/clock ]; then
   . /etc/sysconfig/clock

   # convert old style clock config to new values
   if [ "${CLOCKMODE}" = "GMT" ]; then
      UTC=true
   elif [ "${CLOCKMODE}" = "ARC" ]; then
      ARC=true
   fi
fi

CLOCKDEF=""
CLOCKFLAGS="$CLOCKFLAGS --systohc"

case "$UTC" in
   yes|true)
	CLOCKFLAGS="$CLOCKFLAGS -u";
	CLOCKDEF="$CLOCKDEF (utc)";
	;;
   no|false)
	CLOCKFLAGS="$CLOCKFLAGS --localtime";
	CLOCKDEF="$CLOCKDEF (localtime)";
	;;
esac

case "$ARC" in
   yes|true)
	CLOCKFLAGS="$CLOCKFLAGS -A";
	CLOCKDEF="$CLOCKDEF (arc)";
	;;
esac
case "$SRM" in
   yes|true)
	CLOCKFLAGS="$CLOCKFLAGS -S";
	CLOCKDEF="$CLOCKDEF (srm)";
	;;
esac

[ -x /sbin/hwclock ] && action "Syncing hardware clock to system time" /sbin/hwclock $CLOCKFLAGS

# Try to unmount tmpfs filesystems to avoid swapping them in.  Ignore failures.
tmpfs=$(awk '$2 ~ /^\/($|proc|dev)/ { next; }
	     $3 == "tmpfs" { print $2; }' /proc/mounts | sort -r)
[ -n "$tmpfs" ] && fstab-decode umount $tmpfs 2>/dev/null

# Turn off swap, then unmount file systems.
[ -f /proc/swaps ] && SWAPS=`awk '! /^Filename/ { print $1 }' /proc/swaps`
if [ -n "$SWAPS" ]; then
    action "Turning off swap: " swapoff $SWAPS
    for dst in $SWAPS; do
	if [[ "$dst" =~ ^/dev/mapper ]] \
	    && [ "$(dmsetup status "$dst" | cut -d ' ' -f 3)" = crypt ]; then
	    backdev=$(/sbin/cryptsetup status "$dst" \
		| awk '$1 == "device:" { print $2 }')
	    /sbin/cryptsetup remove "$dst"
	    # Leave partition with a blank plain-text swap
	    mkswap "$backdev" > /dev/null
	fi
    done
fi

[ -x /sbin/quotaoff ] && action "Turning off quotas: " /sbin/quotaoff -aug

# first remove entry /initrd/loopfs as it can't be unmounted :(
mtab=$(fgrep -v "/initrd/loopfs[^/]" /etc/mtab)
(IFS= ; echo $mtab > /etc/mtab)

# Unmount file systems, killing processes if we have to.
# Unmount loopback stuff first
__umount_loopback_loop

# Unmount RPC pipe file systems
__umount_loop '$3 ~ /^rpc_pipefs$/ || $3 ~ /^rpc_svc_gss_pipefs$/ {print $2}' \
    /proc/mounts \
    "Unmounting pipe file systems: " \
    "Unmounting pipe file systems (retry): " \
    -f

# DRBL comment the tmpfs, which we use to replace devfs in DRBL clients.
#LANG=C __umount_loop '$2 ~ /^\/$|^\/proc|^\/dev/{next}
#	$3 == "tmpfs" || $3 == "proc" {print $2 ; next}
#	/(loopfs|autofs|nfs|cifs|smbfs|ncpfs|sysfs|^none|^\/dev\/ram|^\/dev\/root$)/ {next}
LANG=C __umount_loop '$2 ~ /^\/$|^\/proc|^\/dev/{next}
	$3 == "proc" {print $2 ; next}
	/(loopfs|autofs|nfs|cifs|smbfs|ncpfs|sysfs|^none|^\/dev\/ram|^\/dev\/root$)/ {next}
	{print $2}' /proc/mounts \
	"Unmounting file systems: " \
	"Unmounting file systems (retry): " \
	-f

if [ -f /etc/lvm/lvm.conf -a -x /sbin/lvm2 ]; then
	if grep -q -s 'device-mapper' /proc/devices; then
		_vgchange_cmd="/sbin/lvm2 vgchange -a n"
	fi
fi

if [ -z "${_vgscan_cmd}" -a -f /etc/lvmtab -a -e /proc/lvm ] ; then
	if [ -x /sbin/lvm1-vgchange ]; then
		_vgchange_cmd="/sbin/lvm1-vgchange -a n"
	elif [ -x /sbin/vgchange ]; then
		_vgchange_cmd="/sbin/vgchange -a n"
	fi
fi

if [ -n "${_vgchange_cmd}" ]; then
    action "Shutting down LVM:" ${_vgchange_cmd}
fi

# for NUT
# do it here to have /proc/usb mounted for UPS on USB
if [ -f /etc/init.d/upsd ]; then
    /etc/init.d/upsd powerdown
    [ $? == 3 ] && exit 1
fi

[ -f /proc/bus/usb/devices ] && umount /proc/bus/usb

[ -f /etc/crypttab ] && \
    LANG=C action "Stopping disk encryption: " halt_crypto

# remove the crash indicator flag
rm -f /.autofsck

# Try all file systems other than root, essential filesystems and RAM disks,
# one last time.
# DRBL, add /dev, /sys, /etc, /var so it will not be umount...
#awk '$2 !~ /\/(|dev|proc|selinux)$/ && $1 !~ /^\/dev\/ram/ { print $2 }' \
awk '$2 !~ /\/(|dev|proc|selinux|sys|etc|var)$/ && $1 !~ /^\/dev\/ram/ && $3 !~ /nfs/ { print $2 }' \
    /proc/mounts | sort -r | \
  while read line; do
    fstab-decode umount -f $line
done

if [ -x /sbin/halt.local ]; then
   /sbin/halt.local
fi

# Remount read only anything that's left mounted.
# gprintf "Remounting remaining filesystems readonly\n"
# DRBL added codes to exclude nfs for being remounted again.
#mount | awk '{ print $3 }' | while read line; do
mount | awk '$5 !~ /nfs/ { print $3 }' | while read line; do
    fstab-decode mount -n -o ro,remount $line
done

action "Unmounting proc file system: " umount /proc

# See if this is a powerfail situation.
if [ -f /etc/apcupsd/powerfail ]; then
  gprintf "APCUPSD will now power off the UPS!\n"
  echo
  /etc/apcupsd/apccontrol killpower
  echo
  gprintf "Please ensure that the UPS has powered off before rebooting\n"
  gprintf "Otherwise, the UPS may cut the power during the reboot!!!\n"
  echo
fi

# Now halt or reboot.
echo "$message"
if [ -f /fastboot ]; then
 gprintf "On the next boot fsck will be skipped.\n"
elif [ -f /forcefsck ]; then
 gprintf "On the next boot fsck will be forced.\n"
fi

# First, try kexec. If that fails, fall back to rebooting the old way.
[ -n "$kexec_command" ] && $kexec_command -e -x >& /dev/null

# DRBL Remove -i to avoid network down. Need this for Wake on LAN.
#HALTARGS="-i -d -p"
HALTARGS="-d -p"

exec $command $HALTARGS
