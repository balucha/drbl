#!/bin/bash
#
# /etc/rc.d/rc.sysinit - run once at boot time
#
# Taken in part from Miquel van Smoorenburg's bcheckrc.
#

HOSTNAME=`/bin/hostname`

. /etc/init.d/functions

set -m

if [ -f /etc/sysconfig/network ]; then
    . /etc/sysconfig/network
fi

# Read in config data.
if [ -f /etc/sysconfig/system ]; then
    . /etc/sysconfig/system
fi

if [ -z "$HOSTNAME" -o "$HOSTNAME" = "(none)" ]; then
    HOSTNAME=localhost
fi

if [ ! -e /proc/mounts ]; then 
	mount -n -t proc /proc /proc
	mount -n -t sysfs /sys /sys >/dev/null 2>&1
fi

# Only read this once.
cmdline=$(cat /proc/cmdline)

for t in $cmdline; do
  case $t in
      -s|single|S|s) REQUESTED_RUNLEVEL="S" ;;
      [1-9])       REQUESTED_RUNLEVEL="$t" ;;
  esac
done
[ -z "$REQUESTED_RUNLEVEL" ] && REQUESTED_RUNLEVEL=$(/bin/awk -F ':' '$3 == "initdefault" && $1 !~ "^#" { print $2 }' /etc/inittab)
[ -z "$REQUESTED_RUNLEVEL" ] && REQUESTED_RUNLEVEL="3"

# eugeni: killing splashy when using single-user mode
if [ "$REQUESTED_RUNLEVEL" == "S" ]; then
	[ -x /sbin/splashy_update ] && /sbin/splashy_update exit 2>/dev/null
fi

uname_r=`uname -r`

# Read in config data.
if [ -f /etc/sysconfig/speedboot ]; then
    . /etc/sysconfig/speedboot
fi

if strstr "$cmdline" speedboot= ; then
     for arg in $cmdline ; do
         if [ "${arg##speedboot=}" != "${arg}" ]; then
             SPEEDBOOT=${arg##speedboot=}
         fi
     done
fi

if [ "$REQUESTED_RUNLEVEL" != 5 -o -f /etc/rc.d/rc5.d/S*network-auth ]; then
  SPEEDBOOT=no
fi

if [ "$SPEEDBOOT" = "probe" ]; then
     SPEEDBOOT_PROBE=yes
fi

if [ "x$SPEEDBOOT" = "xauto" ]; then
     STATUS=`grep -m 1 "$uname_r"  /var/lib/speedboot/status 2>/dev/null`
     case "$STATUS" in 
	     *first\ time*) SPEEDBOOT=yes ;;
	     *FAILED*) SPEEDBOOT=no ;;
	     *OK*) SPEEDBOOT=yes ;;
	     *STANDARD\ BOOT*) SPEEDBOOT=yes ;;
	     *) SPEEDBOOT=no ;;
     esac
fi

if [ "$SPEEDBOOT" = "yes" ]; then
  export SPEEDBOOT
  PROMPT=no
else
  unset SPEEDBOOT
fi

if [ "x$SPEEDBOOT" != "xyes" ]; then
if [ ! -d /proc/bus/usb ]; then
	modprobe usbcore >/dev/null 2>&1 && mount -n -t usbfs -o devmode=0664,devgid=43 /proc/bus/usb /proc/bus/usb
else
	mount -n -t usbfs -o devmode=0664,devgid=43 /proc/bus/usb /proc/bus/usb
fi
fi #SPEEDBOOT

if [ -f /.readahead_collect -a -r /etc/sysconfig/readahead ]; then
    . /etc/sysconfig/readahead
    if [ "x$READAHEAD_COLLECT" == "xyes" -a ! -f /forcefsck -a -x /sbin/readahead-collector ]; then
	   /sbin/readahead-collector
    fi
elif [ -x /sbin/readahead_early ]; then
    /sbin/readahead_early &
fi
 
if [ -x /etc/rc.early.local ]; then
    . /etc/rc.early.local
fi

# This must be done before anything else because now most messages
# are translated so we need correct system font very early
# This must be done before Aurora is started too, since screenchars
# --tty=foo is broken :(
# Note that if setting of system font fails here boot messages
# may be unreadable so we may need to reset LANGUAGE to C in this case
# Load system font
#
# the font and other needed files should be available under
# /etc/sysconfig/console, in case they aren't we define DELAYED_FONT=yes
# to load the font later, when the /usr partition is mounted
if [ -x /sbin/setsysfont ]; then
	[ -r /usr/lib/kbd/consolefonts ] || DELAYED_FONT=yes
	[ -x /usr/bin/locale ] || DELAYED_FONT=yes
	# We have to set font before printing message, so we cannot
	# use ``action message command'' directly because it prints
	# message before executing command
	if [ "$DELAYED_FONT" != "yes" ]; then
		action "Setting default font ($SYSFONT): " /sbin/setsysfont
		OUR_CHARSET=${CHARSET=`get_locale_encoding`}
		# this is done by unicode_start, but apparently
		# "action" filters the output, so it has to be redone
		[ "$OUR_CHARSET" != "UTF-8" ] || echo -n -e '\033%G'
	else
		reset_i18_settings
	fi
fi


# Unmount the initrd, if necessary
# (pixel) do not unmount if /initrd/loopfs is mounted (happens for root loopback)
# (bluca) handle udev /dev tmpfs here since kernel will happily umount /dev after initrd end
# (blino) do it before the udev service is started so that it uses the /dev tmpfs from initrd
if LC_ALL=C grep -q /initrd /proc/mounts && ! LC_ALL=C grep -q /initrd/loopfs /proc/mounts ; then
   if LC_ALL=C grep -q /initrd/dev /proc/mounts; then
         mount --move /initrd/dev /dev
   fi
   action "Unmounting initrd: " umount -l /initrd
   /sbin/blockdev --flushbufs /dev/ram0 >/dev/null 2>&1
fi

if [ "x$SPEEDBOOT" = "xyes" ]; then
   /sbin/start_udev 
   udevadm trigger --subsystem-match=pci --attr-match=class="0x0c03*"
   udevadm trigger --subsystem-match=block
   udevadm settle &
   UDEV_DISK_PID=$!
   udevadm trigger --subsystem-match=mem --subsystem-match=input --subsystem-match=tty --subsystem-match=acpi
   udevadm trigger --subsystem-match=pci --attr-match=class="0x060000*"
   udevadm settle &
   UDEV_PID=$!
fi

PLYMOUTH=
[ -x /usr/bin/plymouth ] && PLYMOUTH=yes

# Check SELinux status
selinuxfs="$(fstab_decode_str `LC_ALL=C awk '/ selinuxfs / { print $2 }' /proc/mounts`)"
SELINUX_STATE=
if [ -n "$selinuxfs" ] && [ "`cat /proc/self/attr/current`" != "kernel" ]; then
	if [ -r "$selinuxfs/enforce" ] ; then
		SELINUX_STATE=`cat "$selinuxfs/enforce"`
	else
		# assume enforcing if you can't read it
		SELINUX_STATE=1
	fi
fi

if [ -n "$SELINUX_STATE" -a -x /sbin/restorecon ] && __fgrep " /dev " /proc/mounts >/dev/null 2>&1 ; then
	/sbin/restorecon  -R /dev 2>/dev/null
fi

disable_selinux() {
	gprintf "*** Warning -- SELinux is active\n"
	gprintf "*** Disabling security enforcement for system recovery.\n"
	gprintf "*** Run 'setenforce 1' to reenable.\n"
	echo "0" > "$selinuxfs/enforce"
}

relabel_selinux() {
    # if /sbin/init is not labeled correctly this process is running in the 
    # wrong context, so a reboot will be required after relabel
    REBOOTFLAG=`restorecon -v /sbin/init`
    AUTORELABEL=
    . /etc/selinux/config
    if [ "$AUTORELABEL" = "0" ]; then
 	rm -f  /.autorelabel 

	[ -n "$PLYMOUTH" ] && plymouth --hide-splash 
 	echo
	gprintf "*** Warning -- SELinux %s policy relabel is required.\n" ${SELINUXTYPE}
 	gprintf "*** /etc/selinux/config indicates you want to manually fix labeling\n"
 	gprintf "*** problems. Dropping you to a shell; the system will reboot\n"
 	gprintf "*** when you leave the shell.\n"
 	echo "0" > $selinuxfs/enforce
 	sulogin
 
 	gprintf "Unmounting file systems\n"
 	umount -a
 	mount -n -o remount,ro /
 	gprintf "Automatic reboot in progress.\n"
 	reboot -f
    else
	[ -n "$PLYMOUTH" ] && plymouth --hide-splash 
 	echo
 	gprintf "*** Warning -- SELinux %s policy relabel is required.\n" ${SELINUXTYPE}
 	gprintf "*** Relabeling could take a very long time, depending on file\n"
 	gprintf "*** system size and speed of hard drives.\n"
 
 	echo "0" > $selinuxfs/enforce
	/sbin/fixfiles -F restore > /dev/null 2>&1
 	rm -f  /.autorelabel 
 	if [ ! -z "$REBOOTFLAG" ]; then 
 	    gprintf "Automatic reboot in progress.\n"
 	    reboot -f
 	fi
 	echo $SELINUX_STATE > $selinuxfs/enforce
	[ -n "$PLYMOUTH" ] && plymouth --show-splash 
    fi
}

key_is_random() {
    [ "$1" = "/dev/urandom" -o "$1" = "/dev/hw_random" \
	-o "$1" = "/dev/random" ]
}

find_crypto_mount_point() {
    local fs_spec fs_file fs_vfstype remaining_fields
    local fs
    while read fs_spec fs_file remaining_fields; do
	if [ "$fs_spec" = "/dev/mapper/$1" ]; then
	    echo $fs_file
	    break;
	fi
    done < /etc/fstab
}

# Because of a chicken/egg problem, init_crypto must be run twice.  /var may be
# encrypted but /var/lib/random-seed is needed to initialize swap.
init_crypto() {
    local have_random dst src key opt mode owner params makeswap skip arg opt
    local param value rc ret mke2fs mdir prompt mount_point

    ret=0
    have_random=$1
    while read dst src key opt; do
	[ -z "$dst" -o "${dst#\#}" != "$dst" ] && continue
        [ -b "/dev/mapper/$dst" ] && continue;
	if [ "$have_random" = 0 ] && key_is_random "$key"; then
	    continue
	fi
	if [ -n "$key" -a "x$key" != "xnone" ]; then
	    if test -e "$key" ; then
		owner=$(ls -l $key | (read a b owner rest; echo $owner))
		if ! key_is_random "$key"; then
		    mode=$(ls -l "$key" | cut -c 5-10)
		    if [ "$mode" != "------" ]; then
		       gprintf "INSECURE MODE FOR %s\n" $key
		    fi
		fi
		if [ "$owner" != root ]; then
		    gprintf "INSECURE OWNER FOR %s\n" $key
		fi
	    else
		gprintf "Key file for %s not found, skipping\n" $dst
		ret=1
		continue
	    fi
	else
	    key=""
	fi
	params=""
	makeswap=""
	mke2fs=""
	skip=""
	# Parse the src field for UUID= and convert to real device names
	if [ "${src%%=*}" == "UUID" ]; then
		src=$(/sbin/blkid -t "$src" -l -o device)
	elif [ "${src/^\/dev\/disk\/by-uuid\/}" != "$src" ]; then
		src=$(__readlink $src)
	fi
	# Is it a block device?
	[ -b "$src" ] || continue
	# Is it already a device mapper slave? (this is gross)
	devesc=${src##/dev/}
	devesc=${devesc//\//!}
	for d in /sys/block/dm-*/slaves ; do
	    [ -e $d/$devesc ] && continue 2
	done
	# Parse the options field, convert to cryptsetup parameters and
	# contruct the command line
	while [ -n "$opt" ]; do
	    arg=${opt%%,*}
	    opt=${opt##$arg}
	    opt=${opt##,}
	    param=${arg%%=*}
	    value=${arg##$param=}

	    case "$param" in
	    cipher)
		params="$params -c $value"
		if [ -z "$value" ]; then
		    gprintf "%s: no value for cipher option, skipping\n" $dst
		    skip="yes"
		fi
	    ;;
	    size)
		params="$params -s $value"
		if [ -z "$value" ]; then
		    gprintf "%s: no value for size option, skipping\n" $dst
		    skip="yes"
		fi
	    ;;
	    hash)
		params="$params -h $value"
		if [ -z "$value" ]; then
		    gprintf "%s: no value for hash option, skipping\n" $dst
		    skip="yes"
		fi
	    ;;
	    verify)
	        params="$params -y"
	    ;;
	    swap)
		makeswap=yes
		;;
	    tmp)
		mke2fs=yes
	    esac
	done
	if [ "$skip" = "yes" ]; then
	    ret=1
	    continue
	fi
	if [ -z "$makeswap" ] && cryptsetup isLuks "$src" 2>/dev/null ; then
	    if key_is_random "$key"; then
		gprintf "%s: LUKS requires non-random key, skipping\n" $dst
		ret=1
		continue
	    fi
	    if [ -n "$params" ]; then
		echo "$dst: options are invalid for LUKS partitions," \
		    "ignoring them"
	    fi
	    if [ -n "$key" ]; then
		/sbin/cryptsetup -d $key luksOpen "$src" "$dst" <&1 2>/dev/null && success || failure
	    else
		mount_point="$(find_crypto_mount_point $dst)"
		[ -n "$mount_point" ] || mount_point=${src##*/}
		prompt=$(printf "%s is password protected" "$mount_point")
                if [ -n "$PLYMOUTH" ]; then
                    plymouth ask-for-password --prompt "$prompt" --command="/sbin/cryptsetup luksOpen -T1 $src $dst" <&1
                else
                    # stop splashy to ask for password
                    update_boot_stage exit
                    /sbin/cryptsetup luksOpen "$src" "$dst" <&1 && success || failure
                fi
	    fi
	else
	    [ -z "$key" ] && plymouth --hide-splash
	    /sbin/cryptsetup $params ${key:+-d $key} create "$dst" "$src" <&1 2>/dev/null && success || failure
	    [ -z "$key" ] && plymouth --show-splash
	fi
	rc=$?
	if [ $rc -ne 0 ]; then
	    ret=1
	    continue
	fi
	if [ -b "/dev/mapper/$dst" ]; then
	    if [ "$makeswap" = "yes" ]; then
		mkswap "/dev/mapper/$dst" 2>/dev/null >/dev/null
	    fi
	    if [ "$mke2fs" = "yes" ]; then
		if mke2fs "/dev/mapper/$dst" 2>/dev/null >/dev/null \
		    && mdir=$(mktemp -d /tmp/mountXXXXXX); then
		    mount "/dev/mapper/$dst" "$mdir" && chmod 1777 "$mdir"
		    umount "$mdir"
		    rmdir "$mdir"
		fi
	    fi
	fi
    done < /etc/crypttab
    return $ret
}

# Print a text banner.
# C-like escape sequences don't work as 2nd and up parameters of gprintf,
# so real escap chars were written
PRODUCT=`sed "s/.*release \([0-9.]*\).*/\1/g" /etc/mandriva-release 2> /dev/null`
SYSTEM=${SYSTEM="Mandriva Linux"}

if [ -r /etc/sysconfig/oem ]; then
    . /etc/sysconfig/oem
fi

if [ "$BOOTUP" != "serial" ]; then
 gprintf "\t\t\tWelcome to %s" "`echo -en '\\033[1;36m'`$SYSTEM`echo -en '\\033[0;39m'` $PRODUCT"
else
 gprintf "\t\t\tWelcome to %s" "$SYSTEM $PRODUCT"
fi
echo -en "\r"
echo
if [ "$PROMPT" != "no" ]; then
 gprintf "\t\tPress 'I' to enter interactive startup."
 echo
fi

# Fix console loglevel
if [ -n "$LOGLEVEL" ]; then
	/bin/dmesg -n $LOGLEVEL
fi

initsplash 5
rc_splash start 1

# Initialize hardware
if [ -f /proc/sys/kernel/modprobe ]; then
   if strstr "$cmdline" nomodules || [ ! -f /proc/modules ] ; then
       # We used to set this to NULL, but that causes 'failed to exec' messages"
       sysctl -w kernel.modprobe="/bin/true" >/dev/null 2>&1
   fi
fi

touch /dev/.in_sysinit >/dev/null 2>&1

# Set default affinity
if [ -x /bin/taskset ]; then
   if strstr "$cmdline" default_affinity= ; then
     for arg in $cmdline ; do
         if [ "${arg##default_affinity=}" != "${arg}" ]; then
             /bin/taskset -p ${arg##default_affinity=} 1
         fi
     done
   fi
fi

nashpid=$(pidof nash 2>/dev/null)
[ -n "$nashpid" ] && kill $nashpid >/dev/null 2>&1
unset nashpid
if [ "x$SPEEDBOOT" != "xyes" ]; then
  /sbin/start_udev
fi #SPEEDBOOT

# Load other user-defined modules
for file in /etc/sysconfig/modules/*.modules ; do
  [ -x $file ] && $file
done

# Load modules (for backward compatibility with VARs)
if [ -f /etc/rc.modules ]; then
  if [ "x$SPEEDBOOT" != "xyes" ]; then
	/etc/rc.modules
  else
	ionice -c 3 /etc/rc.modules &
  fi
fi

mount -n -t devpts -o mode=620 none /dev/pts >/dev/null 2>&1
[ -n "$SELINUX_STATE" ] && restorecon /dev/pts >/dev/null 2>&1

mount -n -t tmpfs  none /dev/shm >/dev/null 2>&1

# Configure kernel parameters
update_boot_stage RCkernelparam
sysctl -e -p /etc/sysctl.conf >/dev/null 2>&1

if [ "x$SPEEDBOOT" != "xyes" ]; then

# If brltty exist start it (after udev so that vcsa device nodes are created)
[ -x /bin/brltty -a "$BRLTTY" != "no" ] && action "Starting braille terminal" /bin/brltty && SPEEDBOOT="DISABLED reason: braille"

if [ -x /bin/loadkeys ]; then
 KEYTABLE=
 KEYMAP=
 if [ -f /etc/sysconfig/console/default.kmap ]; then
  KEYMAP=/etc/sysconfig/console/default.kmap
 else
  if [ -f /etc/sysconfig/keyboard ]; then
    . /etc/sysconfig/keyboard
  fi
  if [ -n "$KEYTABLE" -a -d /usr/lib/kbd/keymaps -o -d /lib/kbd/keymaps ]; then
     KEYMAP="$KEYTABLE"
  fi
 fi
 if [ -n "$KEYMAP" ]; then 
  if [ -n "$KEYTABLE" ]; then
    gprintf "Loading default keymap (%s): " $KEYTABLE
  else
    gprintf "Loading default keymap: "
  fi
  LOADKEYS=loadkeys
  if [ "${LANG}" != "${LANG%%.UTF-8}" -o "${LANG}" != "${LANG%%.utf8}" ]; then
  	LOADKEYS="loadkeys -u"
  fi
  $LOADKEYS $KEYMAP < /dev/tty0 > /dev/tty0 2>/dev/null && \
     success "Loading default keymap" || failure "Loading default keymap"
  echo
 fi
fi
fi #SPEEDBOOT

# Set the hostname.
update_boot_stage RChostname
action "Setting hostname %s: " ${HOSTNAME} hostname ${HOSTNAME}

# Set the NIS domain name
if [ -n "$NISDOMAIN" ]; then
    action "Setting NIS domain name %s: " $NISDOMAIN nisdomainname $NISDOMAIN
fi

if [ "x$SPEEDBOOT" != "xyes" ]; then
# Now that we load only one scsi_hostadapter in the initrd, we
# need to load the others here
modprobe scsi_hostadapter >/dev/null 2>&1
# Now that we use modular IDE, we need to do the same for IDE controllers
modprobe ide-controller >/dev/null 2>&1

# Start any MD RAID arrays that haven't been started yet
if [ -f /etc/mdadm.conf -a -x /sbin/mdadm ]; then
       /sbin/mdadm -As --auto=yes --run
       SPEEDBOOT="DISABLED: reason:MD RAID"
fi

# Device mapper & related initialization
if ! __fgrep "device-mapper" /proc/devices >/dev/null 2>&1 ; then
       modprobe dm-mod >/dev/null 2>&1
fi

if [ -f /etc/crypttab ]; then
    init_crypto 0
fi

        if ! strstr "$cmdline" nompath && [ -f /etc/multipath.conf -a \
			-x /sbin/multipath ]; then
		modprobe dm-multipath > /dev/null 2>&1
		/sbin/multipath -v 0
		if [ -x /sbin/kpartx ]; then
			/sbin/dmsetup ls --target multipath --exec "/sbin/kpartx -a -p p" >/dev/null
		fi
	fi
	
	if ! strstr "$cmdline" nodmraid && [ -x /sbin/dmraid ]; then
		modprobe dm-mirror >/dev/null 2>&1
		for x in $(/sbin/dmraid -ay -i -p -t 2>/dev/null | \
				egrep -iv "^no " | \
				(IFS=":";while read a rest;do echo $a;done)) ; do
			dmname=$(resolve_dm_name $x)
			[ -z "$dmname" ] && continue
			/sbin/dmraid -ay -i -p "$dmname" >/dev/null 2>&1
			/sbin/kpartx -a -p p "/dev/mapper/$dmname"
    			SPEEDBOOT="DISABLED reason:dmraid"
		done
	fi
	
	if [ -x /sbin/lvm ]; then
		action "Setting up Logical Volume Management:" /sbin/lvm vgchange -a y --ignorelockingfailure
	    	SPEEDBOOT="DISABLED reason: LVM"
	fi

if [ -f /etc/crypttab ]; then
    init_crypto 0
fi
fi

if [ -f /fastboot ] || strstr "$cmdline" fastboot ; then
	fastboot=yes
fi

if [ -f /fsckoptions ]; then
	fsckoptions=`cat /fsckoptions`
fi

# (blino) always source autofsck settings, for AUTOFSCK_CRYPTO_TIMEOUT (#16029)
[ -f /etc/sysconfig/autofsck ] && . /etc/sysconfig/autofsck

if [ -f /forcefsck ] || strstr "$cmdline" forcefsck ; then
	fsckoptions="-f $fsckoptions"
elif [ -f /.autofsck ]; then
	if [ "$AUTOFSCK_DEF_CHECK" = "yes" ]; then
		AUTOFSCK_OPT="$AUTOFSCK_OPT -f"
	fi
	if [ -n "$AUTOFSCK_SINGLEUSER" ]; then
		[ -n "$PLYMOUTH" ] && plymouth --hide-splash 
		rc_splash verbose
		echo
		gprintf "*** Warning -- the system did not shut down cleanly. \n"
		gprintf "*** Dropping you to a shell; the system will continue\n"
		gprintf "*** when you leave the shell.\n"
		[ -n "$SELINUX_STATE" ] && echo "0" > $selinuxfs/enforce
		sulogin
		[ -n "$SELINUX_STATE" ] && echo "1" > $selinuxfs/enforce
		[ -n "$PLYMOUTH" ] && plymouth --show-splash 
	fi
	fsckoptions="$AUTOFSCK_OPT $fsckoptions"
fi

if [ "$BOOTUP" = "color" ]; then
	fsckoptions="-C $fsckoptions"
else
	fsckoptions="-V $fsckoptions"
fi

READONLY=
if [ -f /etc/sysconfig/readonly-root ]; then
	. /etc/sysconfig/readonly-root
fi
if strstr "$cmdline" readonlyroot ; then
	READONLY=yes
	[ -z "$RW_MOUNT" ] && RW_MOUNT=/var/lib/stateless/writable
	[ -z "$STATE_MOUNT" ] && STATE_MOUNT=/var/lib/stateless/state
fi
if strstr "$cmdline" noreadonlyroot ; then
	READONLY=no
fi

if [ "$READONLY" = "yes" -o "$TEMPORARY_STATE" = "yes" ]; then

	mount_empty() {
		if [ -e "$1" ]; then
			echo "$1" | cpio -p -vd "$RW_MOUNT" &>/dev/null
			mount -n --bind "$RW_MOUNT$1" "$1"
		fi
	}

	mount_dirs() {
		if [ -e "$1" ]; then
			mkdir -p "$RW_MOUNT$1"
			find "$1" -type d -print0 | cpio -p -0vd "$RW_MOUNT" &>/dev/null
			mount -n --bind "$RW_MOUNT$1" "$1"
		fi
	}

	mount_files() {
		if [ -e "$1" ]; then
			cp -a --parents "$1" "$RW_MOUNT"
			mount -n --bind "$RW_MOUNT$1" "$1"
		fi
	}

	# Common mount options for scratch space regardless of 
	# type of backing store
	mountopts=

	# Scan partitions for local scratch storage
	rw_mount_dev=$(blkid -t LABEL="$RW_LABEL" -l -o device)

	# First try to mount scratch storage from /etc/fstab, then any
	# partition with the proper label.  If either succeeds, be sure
	# to wipe the scratch storage clean.  If both fail, then mount
	# scratch storage via tmpfs.
	if mount $mountopts "$RW_MOUNT" > /dev/null 2>&1 ; then
		rm -rf "$RW_MOUNT" > /dev/null 2>&1
	elif [ x$rw_mount_dev != x ] && mount $rw_mount_dev $mountopts "$RW_MOUNT" > /dev/null 2>&1; then
		rm -rf "$RW_MOUNT"  > /dev/null 2>&1
	else
		mount -n -t tmpfs $RW_OPTIONS $mountopts none "$RW_MOUNT"
	fi

	for file in /etc/rwtab /etc/rwtab.d/* ; do
		is_ignored_file "$file" && continue
        	[ -f $file ] && cat $file | while read type path ; do
			case "$type" in
				empty)
					mount_empty $path
					;;
				files)
					mount_files $path
					;;
				dirs)
					mount_dirs $path
					;;
				*)
					;;
			esac
			[ -n "$SELINUX_STATE" -a -e "$path" ] && restorecon -R "$path"
		done
	done

	# In theory there should be no more than one network interface active
	# this early in the boot process -- the one we're booting from.
	# Use the network address to set the hostname of the client.  This
	# must be done even if we have local storage.
	ipaddr=
	if [ "$HOSTNAME" = "localhost" -o "$HOSTNAME" = "localhost.localdomain" ]; then
		ipaddr=$(ip addr show to 0.0.0.0/0 scope global | awk '/[[:space:]]inet / { print gensub("/.*","","g",$2) }')
		if [ -n "$ipaddr" ]; then
			eval $(ipcalc -h $ipaddr 2>/dev/null)
			hostname ${HOSTNAME}
		fi
	fi
	
	# Clients with read-only root filesystems may be provided with a
	# place where they can place minimal amounts of persistent
	# state.  SSH keys or puppet certificates for example.
	#
	# Ideally we'll use puppet to manage the state directory and to
	# create the bind mounts.  However, until that's all ready this
	# is sufficient to build a working system.

	# First try to mount persistent data from /etc/fstab, then any
	# partition with the proper label, then fallback to NFS
	state_mount_dev=$(blkid -t LABEL="$STATE_LABEL" -l -o device)
	if mount $mountopts $STATE_OPTIONS "$STATE_MOUNT" > /dev/null 2>&1 ; then
		/bin/true
	elif [ x$state_mount_dev != x ] && mount $state_mount_dev $mountopts "$STATE_MOUNT" > /dev/null 2>&1;  then
		/bin/true
	elif [ ! -z "$CLIENTSTATE" ]; then
		# No local storage was found.  Make a final attempt to find 
		# state on an NFS server.

		mount -t nfs $CLIENTSTATE/$HOSTNAME $STATE_MOUNT -o rw,nolock
	fi

	if [ -w "$STATE_MOUNT" ]; then

		mount_state() {
			if [ -e "$1" ]; then
				[ ! -e "$STATE_MOUNT$1" ] && cp -a --parents "$1" "$STATE_MOUNT"
				mount -n --bind "$STATE_MOUNT$1" "$1"
			fi
		}

		for file in /etc/statetab /etc/statetab.d/* ; do
			is_ignored_file "$file" && continue
			[ ! -f "$file" ] && continue

			if [ -f "$STATE_MOUNT/$file" ] ; then
				mount -n --bind "$STATE_MOUNT/$file" "$file"
			fi

			for path in $(grep -v "^#" "$file" 2>/dev/null); do
				mount_state "$path"
				[ -n "$SELINUX_STATE" -a -e "$path" ] && restorecon -R "$path"
			done
		done

		if [ -f "$STATE_MOUNT/files" ] ; then
			for path in $(grep -v "^#" "$STATE_MOUNT/files" 2>/dev/null); do
				mount_state "$path"
				[ -n "$SELINUX_STATE" -a -e "$path" ] && restorecon -R "$path"
			done
		fi
	fi
fi
 
if ! [[ " $fsckoptions" =~ " -y" ]]; then
    	fsckoptions="-a $fsckoptions"
fi

_RUN_QUOTACHECK=0
if [ -f /forcequotacheck ] || strstr "$cmdline" forcequotacheck ; then
	_RUN_QUOTACHECK=1
fi
Fsck()
{
	fsck $*
	rc=$?
	
	if [ "$rc" -eq "0" ]; then
		echo_success
		echo
	elif [ "$rc" -eq "1" ]; then
	        echo_passed
		echo
		_RUN_QUOTACHECK=1
	elif [ "$rc" -eq "2" -o "$rc" -eq "3" ]; then 
		gprintf "Unmounting file systems\n"
		umount -a
		mount -n -o remount,ro /
		gprintf "Automatic reboot in progress.\n"
		reboot -f
	elif [ $((rc & 4)) = 4 ]; then 
	# Return code is a or between return codes for the filesystems
	# 4 means that a filesystem remains corrupted
		[ -n "$PLYMOUTH" ] && plymouth --hide-splash 
		rc_splash verbose
	        [ -x /sbin/splashy_update ] && /sbin/splashy_update exit 2>/dev/null
		echo_failure
		echo
		echo
		gprintf "*** An error occurred during the file system check.\n"
		gprintf "*** Dropping you to a shell; the system will reboot\n"
		gprintf "*** when you leave the shell.\n"

                str=`gprintf "(Repair filesystem)"`
		PS1="$str \# # "; export PS1
		[ "$SELINUX_STATE" = "1" ] && disable_selinux
		sulogin

		gprintf "Unmounting file systems\n"
		umount -a
		mount -n -o remount,ro /
		gprintf "Automatic reboot in progress.\n"
		reboot -f
	else
		echo_failure
		echo
		gprintf "*** A non fatal error occurred during the file system check.\n"
	fi
}

remount_needed() {
  local state oldifs
  [ "$READONLY" = "yes" ] && return 1
  state=`LC_ALL=C awk '/ \/ / && ($3 !~ /rootfs/) { print $4 }' /proc/mounts`
  oldifs=$IFS
  IFS=","
  for opt in $state ; do
  	if [ "$opt" = "rw" ]; then
		IFS=$oldifs
		return 1
	fi
  done
  IFS=$oldifs
  return 0
}

if [ "x$SPEEDBOOT" = "xyes" ]; then
 wait $UDEV_DISK_PID
fi
# do not check / if already rw (for example with unionfs)
if [ -z "$fastboot" -a "$READONLY" != "yes" ] && remount_needed; then 
	gprintf "Checking root filesystem\n"
	Fsck -T -a $fsckoptions /
fi
_RUN_QUOTACHECK=0

# Remount the root filesystem read-write.
update_boot_stage RCmountfs
if remount_needed ; then
  action "Remounting root filesystem in read-write mode: " mount -n -o remount,rw /
fi

# wait for usb storage scanning processes to finish
if ! strstr "$cmdline" nousb; then
  LC_ALL=C grep '08' /sys/bus/usb/devices/*/bInterfaceClass >/dev/null 2>&1
  RETVAL=$?
  if [ $RETVAL -eq 0 ]; then 
	countdown=20
 	until [ -d /sys/module/usb_storage -o $countdown -eq 0 ]; do
		usleep 100000; let countdown=$countdown-1;
 	done
	while ps -eocomm | grep -q usb-stor-scan; do 
		sleep 1; 
	done
  fi
fi

if [ "x$SPEEDBOOT" != "xyes" ]; then
# Clean up SELinux labels
if [ -n "$SELINUX_STATE" ]; then
   restorecon /etc/mtab /etc/ld.so.cache /etc/blkid/blkid.tab /etc/resolv.conf >/dev/null 2>&1
   SPEEDBOOT="DISABLED reason: SELinux"
fi

[ -x /sbin/hibernate-cleanup.sh ] && /sbin/hibernate-cleanup.sh start

# If relabeling, relabel mount points.
if [ -n "$SELINUX_STATE" -a "$READONLY" != "yes" ]; then 
    if [ -f /.autorelabel ] || strstr "$cmdline" autorelabel ; then
	restorecon $(awk '!/^#/ && $4 !~ /noauto/ && $2 ~ /^\// { print $2 }' /etc/fstab) >/dev/null 2>&1
    fi
fi
fi

if [ "$READONLY" != "yes" ] ; then
	# Clear mtab
	(> /etc/mtab) &> /dev/null

	# Remove stale backups
	rm -f /etc/mtab~ /etc/mtab~~

	# Enter mounted filesystems into /etc/mtab
	mount -f /
	mount -f /proc >/dev/null 2>&1
	mount -f /sys >/dev/null 2>&1
	mount -f /dev/pts >/dev/null 2>&1
	mount -f /proc/bus/usb >/dev/null 2>&1
fi
# (pixel) also added /initrd/loopfs for loopback root
mount -f /initrd/loopfs 2>/dev/null

if [ -x /sbin/isapnp -a -f /etc/isapnp.conf -a ! -f /proc/isapnp ]; then
    # check for arguments passed from kernel
    if ! strstr "$cmdline" nopnp ; then
	PNP=yes
    fi
    if [ -n "$PNP" ]; then
	action "Setting up ISA PNP devices: " /sbin/isapnp /etc/isapnp.conf
    else
	action "Skipping ISA PNP configuration at users request: " /bin/true
    fi
fi

# tweak isapnp settings if needed.
if [ -n "$PNP" -a  -f /proc/isapnp -a -x /sbin/sndconfig ]; then
    /sbin/sndconfig --mungepnp >/dev/null 2>&1
fi

# Check filesystems
# (pixel) do not check loopback files, will be done later (aren't available yet)
if [ -z "$fastboot" ]; then
        gprintf "Checking filesystems\n"
	Fsck -T -R -A -a -t noopts=loop $fsckoptions
fi

# Mount all other filesystems (except for network bases filesystems and /proc, which is already
# mounted). Contrary to standard usage,
# filesystems are NOT unmounted in single user mode.
# (pixel) also do not mount loopback and encrypted filesystems
# will be done later
(
# export locales (needed by mount.ntfs-3g)
export LC_ALL
export LANG
if [ "$READONLY" != "yes" ] ; then
	action "Mounting local filesystems: " mount -a -t nodevpts,nonfs,nfs4,smbfs,ncpfs,cifs,gfs,gfs2 -O no_netdev,noloop,noencrypted
else
	action "Mounting local filesystems: " mount -a -n -t nodevpts,nfs4,smbfs,ncpfs,cifs,gfs,gfs2 -O no_netdev,noloop,noencrypted
fi
)

if [ "x$SPEEDBOOT" != "xyes" ]; then
[[ -z $AUTOFSCK_CRYPTO_TIMEOUT ]] && AUTOFSCK_CRYPTO_TIMEOUT=15

#Mounting Encrypted filesystem
encrypted_swap=
if [[ ! -f /fastboot ]];then
    encrypted=
    while read -a entry;do
	device=${entry[0]}
	mountpoint=${entry[1]}
	options=${entry[3]}
	type=${entry[2]}
	if [[ $options == *encryption=* || $options == *encrypted* ]];then
	    [[ $options == *noauto* ]] && continue
	    if [[ $type == *swap* ]];then
		encrypted_swap="$encrypted_swap $device"
		continue
	    fi
	    encrypted="$encrypted $mountpoint"
	fi
    done < /etc/fstab
    if [[ -n $encrypted ]];then
	modprobe cryptoloop
	rc_splash verbose
	echo "We have discovered Encrypted filesystems, do you want to mount them now ?"
	MSG=`gprintf "Press Y within %%d seconds to mount your encrypted filesystems..."`
	KEYS=`gprintf "yY"`
	if /sbin/getkey -c $AUTOFSCK_CRYPTO_TIMEOUT -m "$MSG" "$KEYS"; then
	    echo -e '\n'
	    for i in ${encrypted};do
		echo -n "${i} "; mount ${i}
	    done
	else
	    echo -e '\n'
	fi
    fi
fi

# (pixel) Check loopback filesystems
if [ ! -f /fastboot ]; then
        modprobe loop
        gprintf "Checking loopback filesystems"
	Fsck -T -R -A -a -t opts=loop $fsckoptions
fi

fi #SPEEDBOOT

# Mount loopback
action "Mounting loopback filesystems: " mount -a -O loop

if [ "x$SPEEDBOOT" != "xyes" ]; then
# Retry failed udev events now that local filesystems are mounted read-write
# (useful for rules creating network ifcfg files)
/sbin/udevadm trigger --retry-failed

# at this point everything should be mounted; if the loading
# of the system font failed, try again
if [ "$DELAYED_FONT" = "yes" ]; then
	if [ -x /sbin/setsysfont ]; then
		load_i18_settings
		action "Setting default font ($SYSFONT): " /sbin/setsysfont
		OUR_CHARSET=${CHARSET=`get_locale_encoding`}
		# this is done by unicode_start, but apparently
		# "action" filters the output, so it has to be redone
		[ "$OUR_CHARSET" != "UTF-8" ] || echo -n -e '\033%G'
	fi
fi

if [ -x /etc/init.d/keytable -a -d /usr/lib/kbd/keymaps ]; then
    /etc/init.d/keytable start
fi

# Update quotas if necessary
if [ X"$_RUN_QUOTACHECK" = X1 -a -x /sbin/quotacheck ]; then
	action "Checking local filesystem quotas: " /sbin/quotacheck -anug
fi

if [ -x /sbin/quotaon ]; then
    action "Turning on user and group quotas for local filesystems: " /sbin/quotaon -aug
    SPEEDBOOT="DISABLED reason: quota"
fi

# Check to see if a full relabel is needed
if [ -n "$SELINUX_STATE" -a "$READONLY" != "yes" ]; then 
    if [ -f /.autorelabel ] || strstr "$cmdline" autorelabel ; then
	relabel_selinux
    fi
else
    if [ -d /etc/selinux -a "$READONLY" != "yes" ]; then
        [ -f /.autorelabel ] || touch /.autorelabel
    fi
fi
fi #SPEEDBOOT

# Initialize pseudo-random number generator
if [ -f "/var/lib/random-seed" ]; then
	cat /var/lib/random-seed > /dev/urandom
else
	[ "$READONLY" != "yes" ] && touch /var/lib/random-seed
fi
if [ "$READONLY" != "yes" ]; then
	chmod 600 /var/lib/random-seed
	dd if=/dev/urandom of=/var/lib/random-seed count=1 bs=512 2>/dev/null
fi
if [ "x$SPEEDBOOT" != "xyes" ]; then
if [ -f /etc/crypttab ]; then
    init_crypto 1
    SPEEDBOOT="DISABLED reason: crypto FS"
fi

# Configure machine if necessary.
if [ -f /.unconfigured ]; then
    if [ -x /usr/bin/rhgb-client ] && /usr/bin/rhgb-client --ping ; then
	/usr/bin/rhgb-client --quit
    fi

    if [ -x /usr/bin/system-config-keyboard ]; then
	/usr/bin/system-config-keyboard
    fi
    if [ -x /usr/bin/passwd ]; then 
        /usr/bin/passwd root
    fi
    if [ -x /usr/sbin/system-config-network-tui ]; then
	/usr/sbin/system-config-network-tui
    fi
    if [ -x /usr/sbin/timeconfig ]; then
	/usr/sbin/timeconfig
    fi
    if [ -x /usr/sbin/authconfig-tui ]; then
	/usr/sbin/authconfig-tui --nostart
    fi
    if [ -x /usr/sbin/ntsysv ]; then
	/usr/sbin/ntsysv --level 35
    fi

    # Reread in network configuration data.
    if [ -f /etc/sysconfig/network ]; then
	. /etc/sysconfig/network

	# Reset the hostname.
	action "Resetting hostname %s: " ${HOSTNAME} hostname ${HOSTNAME}

	# Reset the NIS domain name.
	if [ -n "$NISDOMAIN" ]; then
	    action "Resetting NIS domain name %s: " $NISDOMAIN nisdomainname $NISDOMAIN
	fi
    fi

    rm -f /.unconfigured
fi
fi

# Clean out /.
rm -f /fastboot /fsckoptions /forcefsck /.autofsck /forcequotacheck /halt \
	/poweroff /.suspended /etc/killpower &> /dev/null

# Do we need (w|u)tmpx files? We don't set them up, but the sysadmin might...
_NEED_XFILES=
[ -f /var/run/utmpx -o -f /var/log/wtmpx ] && _NEED_XFILES=1

# Clean up /var.
rm -rf /var/lock/cvs/* /var/run/screen/*
find /var/lock /var/run ! -type d ! -path '/var/lock/TMP_1ST' -exec rm -f {} \;

if [ "x$SPEEDBOOT" != "xyes" ]; then
# Reset pam_console permissions
[ -x /sbin/pam_console_apply ] && /sbin/pam_console_apply -r
fi #SPEEDBOOT

if [ "x$SPEEDBOOT" = "xyes" ]; then
  wait $UDEV_PID
  /etc/rc.d/rc S &
  RC_PID=$!
fi
{
# Clean up utmp/wtmp
> /var/run/utmp
touch /var/log/wtmp
chgrp utmp /var/run/utmp /var/log/wtmp
chmod 0664 /var/run/utmp /var/log/wtmp
if [ -n "$_NEED_XFILES" ]; then
  > /var/run/utmpx
  touch /var/log/wtmpx
  chgrp utmp /var/run/utmpx /var/log/wtmpx
  chmod 0664 /var/run/utmpx /var/log/wtmpx
fi

# Clean up various /tmp bits
[ -n "$SELINUX_STATE" ] && restorecon /tmp
rm -f /tmp/.X*-lock /tmp/.lock.* /tmp/.gdm_socket /tmp/.s.PGSQL.*
rm -rf /tmp/.X*-unix /tmp/.ICE-unix /tmp/.font-unix /tmp/hsperfdata_* \
       /tmp/kde-* /tmp/ksocket-* /tmp/mc-* /tmp/mcop-* /tmp/orbit-*  \
       /tmp/scrollkeeper-*  /tmp/ssh-* \
       /dev/.in_sysinit /tmp/.fam_socket /tmp/.esd /tmp/.esd-* \
       /tmp/pulse-* /tmp/.sawfish-* /tmp/esrv* /tmp/kio* \
       /var/lib/gdm/core.*

# clean dynamic stuff
for f in /var/lib/gnome/desktop/dynamic_*.desktop /usr/share/apps/kdesktop/Desktop/dynamic_*.desktop; do
    if [ -r $f ]; then
	device=`sed -n 's/# dynamic_device=//p' $f`
	if [ -n "$device" -a ! -e "$device" ]; then
	    rm -f $f
	fi
    fi
done

# Make ICE directory
mkdir -m 1777 -p /tmp/.ICE-unix >/dev/null 2>&1
chown root:root /tmp/.ICE-unix
[ -n "$SELINUX_STATE" ] && restorecon /tmp/.ICE-unix >/dev/null 2>&1

# Start up swapping.
update_boot_stage RCswap
action "Enabling /etc/fstab swaps: " swapon -a -e 2>/dev/null
if [ "$AUTOSWAP" = "yes" ]; then
	curswap=$(awk '/^\/dev/ { print $1 }' /proc/swaps | while read x; do get_numeric_dev dec $x ; echo -n " "; done)
	swappartitions=$(blkid -t TYPE=swap -o device)
	if [ x"$swappartitions" != x ]; then
		for partition in $swappartitions ; do
			[ ! -e $partition ] && continue
			majmin=$(get_numeric_dev dec $partition)
			gprintf "Enabling local swap partitions: \n" swapon $partition
		done
	fi
fi

# Set up binfmt_misc
/bin/mount -t binfmt_misc none /proc/sys/fs/binfmt_misc > /dev/null 2>&1

# Boot time profiles. Yes, this should be somewhere else.
if [ -x /usr/sbin/system-config-network-cmd ]; then
  if strstr "$cmdline" netprofile= ; then
    for arg in $cmdline ; do
        if [ "${arg##netprofile=}" != "${arg}" ]; then
	    /usr/sbin/system-config-network-cmd --profile ${arg##netprofile=}
        fi
    done
  fi
fi

(
# Now turn on swap in case we swap to files.
action "Enabling swap space: " swapon -a -e

if [ "x$SPEEDBOOT" != "xyes" ]; then
# If a SCSI tape has been detected, load the st module unconditionally
# since many SCSI tapes don't deal well with st being loaded and unloaded
if [ -n "$USEMODULES" -a -f /proc/scsi/scsi ] && LC_ALL=C grep -q 'Type:   Sequential-Access' /proc/scsi/scsi 2>/dev/null ; then
    LC_ALL=C fgrep -q ' 9 st' /proc/devices || modprobe st >/dev/null 2>&1
    SPEEDBOOT="DISABLED reason: SCSI tape"
fi
fi #SPEEDBOOT

(
# Turn on harddisk optimization
# There is only one file /etc/sysconfig/harddisks for all disks
# after installing the hdparm-RPM. If you need different hdparm parameters
# for each of your disks, copy /etc/sysconfig/harddisks to
# /etc/sysconfig/harddiskhda (hdb, hdc...) and modify it.
# Each disk which has no special parameters will use the defaults.
# Each non-disk which has no special parameters will be ignored.
# 
 
disk[0]=s;
disk[1]=hda;   disk[2]=hdb;   disk[3]=hdc;   disk[4]=hdd;
disk[5]=hde;   disk[6]=hdf;   disk[7]=hdg;   disk[8]=hdh;
disk[9]=hdi;   disk[10]=hdj;  disk[11]=hdk;  disk[12]=hdl;
disk[13]=hdm;  disk[14]=hdn;  disk[15]=hdo;  disk[16]=hdp;
disk[17]=hdq;  disk[18]=hdr;  disk[19]=hds;  disk[20]=hdt;
disk[21]=sda;  disk[22]=sdb;  disk[23]=sdc;  disk[24]=sdd;
disk[25]=sde;  disk[26]=sdf;  disk[27]=sdg;  disk[28]=sdh;
disk[29]=sr0;  disk[30]=sr1;  disk[31]=sr2;  disk[32]=sr3;
disk[33]=scd0; disk[34]=scd1; disk[35]=scd2; disk[36]=scd3;
disk[37]=sg0;  disk[38]=sg1;  disk[39]=sg2;  disk[40]=sg3;
 
 
# Skip hard disks optimization if software RAID arrays are currently
# resyncing and disks heavily active, because hdparm might hang and
# lock system startup in such situation

if [ ! -f /proc/mdstat ] || ! /bin/egrep -qi "re(cover|sync)|syncing" /proc/mdstat; then
   if [ -x /sbin/hdparm ]; then
       for device in {0..40}; do
	   unset MULTIPLE_IO USE_DMA EIDE_32BIT LOOKAHEAD EXTRA_PARAMS
           if [ -f /etc/sysconfig/harddisk${disk[$device]} ]; then
                   . /etc/sysconfig/harddisk${disk[$device]}
                   HDFLAGS[$device]=
                   if [ -n "$MULTIPLE_IO" ]; then
                       HDFLAGS[$device]="-q -m$MULTIPLE_IO"
                   fi
                   if [ -n "$USE_DMA" ]; then
                       HDFLAGS[$device]="${HDFLAGS[$device]} -q -d$USE_DMA"
                   fi
                   if [ -n "$EIDE_32BIT" ]; then
                       HDFLAGS[$device]="${HDFLAGS[$device]} -q -c$EIDE_32BIT"
                   fi
                   if [ -n "$LOOKAHEAD" ]; then
                       HDFLAGS[$device]="${HDFLAGS[$device]} -q -A$LOOKAHEAD"
                   fi
                   if [ -n "$EXTRA_PARAMS" ]; then
                       HDFLAGS[$device]="${HDFLAGS[$device]} $EXTRA_PARAMS"
                   fi
           else
                   HDFLAGS[$device]="${HDFLAGS[0]}"
           fi
           if [ -e "/proc/ide/${disk[$device]}/media" -o -e "/sys/block/${disk[$device]}/device/vendor" ]; then
                if [ -e "/proc/ide/${disk[$device]}/media" ]; then
			hdmedia=`cat /proc/ide/${disk[$device]}/media`
		else
			hdmedia=`cat /sys/block/${disk[$device]}/device/vendor`
		fi
                if [ "$hdmedia" = "disk" -o "$vendor" = "ATA" -o -f "/etc/sysconfig/harddisk${disk[$device]}" ]; then
                     if [ -n "${HDFLAGS[$device]}" ]; then
                         sleep 2
                         action "Setting hard drive parameters for %s: " ${disk[$device]}  /sbin/hdparm ${HDFLAGS[$device]} /dev/${disk[$device]}
                     fi
                fi
           fi
      done
   fi
else
    action "RAID Arrays are resyncing. Skipping hard drive parameters section." /bin/true
fi
) &


# Adjust symlinks as necessary in /boot to keep system services from
# spewing messages about mismatched System maps and so on.
if [ -L /boot/System.map -a -r /boot/System.map-$uname_r -a \
	! /boot/System.map -ef /boot/System.map-$uname_r ] ; then
	ln -s -f System.map-$uname_r /boot/System.map 2>/dev/null
fi
if [ ! -e /boot/System.map -a -r /boot/System.map-$uname_r ] ; then
	ln -s -f System.map-$uname_r /boot/System.map 2>/dev/null
fi

# Adjust symlinks as necessary in /boot to have the default config
if [ -L /boot/config -a -r /boot/config-$uname_r ] ; then
	ln -sf config-$uname_r /boot/config 2>/dev/null
fi
if [ ! -e /boot/config -a -r /boot/config-$uname_r ] ; then
	ln -sf config-$uname_r /boot/config 2>/dev/null
fi

# Now that we have all of our basic modules loaded and the kernel going,
# let's dump the syslog ring somewhere so we can find it later
[ -f /var/log/dmesg ] && mv -f /var/log/dmesg /var/log/dmesg.old
dmesg -s 131072 > /var/log/dmesg
) &

# create the crash indicator flag to warn on crashes, offer fsck with timeout
touch /.autofsck &> /dev/null

if [ "$PROMPT" != no ]; then
    while :; do
	pid=$(/sbin/pidof getkey)
	[ -n "$pid" -o -e /var/run/getkey_done ] && break
	usleep 100000
    done
    [ -n "$pid" ] && kill -TERM "$pid" >/dev/null 2>&1
fi
} &
if strstr "$cmdline" confirm ; then
	touch /var/run/confirm
fi
if [ "x$SPEEDBOOT" != "xyes" ]; then
if [ "$PROMPT" != "no" ]; then
	/sbin/getkey i && touch /var/run/confirm
	touch /var/run/getkey_done
fi
wait
[ "$PROMPT" != no ] && rm -f /var/run/getkey_done
fi

if strstr "$cmdline" failsafe; then
    touch /var/run/failsafe
fi

if [ -f /var/lock/TMP_1ST ];then
 if [ -f /etc/init.d/mandrake_firstime ];then
	/bin/sh /etc/init.d/mandrake_firstime
 fi
fi

if [ "x$SPEEDBOOT" = "xyes" ]; then
 wait $RC_PID
 countdown=10
 until [ -e /tmp/.X11-unix/X0 -o $countdown -eq 0 ]; do
	sleep 1; let countdown=$countdown-1;
 done


 if [ -x /sbin/readahead_later ]; then
    /sbin/readahead_later &
 fi

 /sbin/udevadm trigger --subsystem-nomatch=tty --subsystem-nomatch=block --subsystem-nomatch=mem --subsystem-nomatch=input --subsystem-nomatch=acpi
 /sbin/udevadm settle --timeout=5 > /dev/null 2>&1
 /sbin/udevadm control --env=STARTUP=
 mount -n -t usbfs -o devmode=0664,devgid=43 /proc/bus/usb /proc/bus/usb
fi

if [ -f /etc/init.d/mandrake_everytime ]; then 
	/bin/sh /etc/init.d/mandrake_everytime
fi
 
if [ "x$SPEEDBOOT_PROBE" = "xyes" ]; then
     sed -i -e "/$uname_r .*/d"  /var/lib/speedboot/status 2>/dev/null
     unset SPEEDBOOT_PROBE
fi

if [ "x$SPEEDBOOT" = "xyes" -a ! -e /tmp/.X11-unix/X0 ]; then
 /etc/init.d/dm stop
 grep -q "$uname_r" /var/lib/speedboot/status 2> /dev/null
 RETVAL=$?
 if [ $RETVAL -eq 0 ]; then
	 sed -i -e "s/^$uname_r FAILED (first time)/$uname_r FAILED/g" -e "/FAILED/!s/^$uname_r .*/$uname_r FAILED (first time)/g" /var/lib/speedboot/status
 else 
	 echo "$uname_r FAILED (first time)" >> /var/lib/speedboot/status
 fi
fi

# system configuration doesn't permit speedboot or speedboot failed, disable it
if strstr "$SPEEDBOOT" DISABLED ; then
 grep -q $uname_r /var/lib/speedboot/status 2> /dev/null 
 RETVAL=$?
 if [ $RETVAL -eq 0 ]; then
	 sed -i -e "s/^$uname_r .*/$uname_r $SPEEDBOOT/g" /var/lib/speedboot/status
 else
	 echo "$uname_r $SPEEDBOOT" >> /var/lib/speedboot/status
 fi
fi

unset SPEEDBOOT

# (pixel) a kind of profile for XF86Config
# if no XFree=XXX given on kernel command-line, restore XF86Config.standard
for i in XF86Config XF86Config-4; do 
    if [ -L "/etc/X11/$i" ]; then
        XFree=`sed -n 's/.*XFree=\(\w*\).*/\1/p' /proc/cmdline`
        [ -n "$XFree" ] || XFree=standard
        [ -r "/etc/X11/$i.$XFree" ] && ln -sf "$i.$XFree" "/etc/X11/$i"
    fi
done

# Let rhgb know that we're leaving rc.sysinit
if [ -x /usr/bin/rhgb-client ] && /usr/bin/rhgb-client --ping ; then
    /usr/bin/rhgb-client --sysinit
fi


