#!/bin/bash
#
# halt          This file is executed by init when it goes into runlevel
#               0 (halt) or runlevel 6 (reboot). It kills all processes,
#               unmounts file systems and then either halts or reboots.
#
# Author:       Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
#               Modified for RHS Linux by Damien Neil
#

NOLOCALE=1
. /etc/init.d/functions

UMOUNT="umount"
[ ! -w /etc ] && UMOUNT="umount -n"

action() {
   echo -n "$1 "
   shift
   if [ "$BOOTUP" = "color" ]; then
      "$@" && echo_success || echo_failure
   else
      "$@"
   fi
   echo
}

halt_crypto() {
    fnval=0
    while read dst src key; do
	[ -z "$dst" -o "${dst#\#}" != "$dst" ] && continue
        if [ -b "/dev/mapper/$dst" ]; then
            if /sbin/dmsetup info "$dst" | grep -q '^Open count: *0$'; then
                action "Stopping disk encryption for %s" $dst /sbin/cryptsetup remove "$dst"
            else
                fnval=1
            fi
        fi
    done < /etc/crypttab
    return $fnval
}

# See how we were called.
case "$0" in
   *halt)
	message=`gprintf "Halting system..."`
	command="/sbin/halt"
	;;
   *reboot)
	message=`gprintf "Please stand by while rebooting the system..."`
	command="/sbin/reboot"
	kexec_command="/sbin/kexec"
	;;
   *)
	gprintf "%s: call me as 'halt' or 'reboot' please!\n" $0
	exit 1
	;;
esac
case "$1" in
   *start)
   	;;
   *)
	gprintf "Usage: %s\n" "$(basename $0) {start}"
	exit 1
	;;
esac

# Recreate the /initrd if needed
if [ ! -d /initrd ]; then
    action "Creating initrd directory" mkdir /initrd
fi
if [ -d /initrd -a ! -f /initrd/README.WARNING ]; then
    cat > /initrd/README.WARNING <<EOF
(mkinitrd) Don't remove this directory, it's needed at boot time,
in the initrd, to perform the pivot_root.
EOF
fi

update_boot_stage kill

# Kill all processes.
[ "${BASH+bash}" = bash ] && enable kill

OMITPIDS=
omitfile=/var/run/sendsigs.omit
if [ -e $omitfile ]; then
    for pid in $(cat $omitfile); do
        OMITPIDS="${OMITPIDS:+$OMITPIDS }-o $pid"
    done
fi

action "Sending all processes the TERM signal..." /sbin/killall5 -15 $OMITPIDS
sleep 2
gprintf "Sending all processes the KILL signal..."
/sbin/killall5 -9 $OMITPIDS
kill_rc=$?
# killall5 will return 2 if no processes are left to kill
if [ "$BOOTUP" = "color" ]; then
    [ \( $kill_rc -eq 2 \) -o \( $kill_rc -eq 0 \) ] && echo_success || echo_failure
fi
echo

# Write to wtmp file before unmounting /var
/sbin/halt -w

# Save random seed
touch /var/lib/random-seed
chmod 600 /var/lib/random-seed
action "Saving random seed: " dd if=/dev/urandom of=/var/lib/random-seed count=1 bs=512 2>/dev/null

update_boot_stage clock
[ -x /sbin/hwclock ] && action "Syncing hardware clock to system time" /sbin/hwclock --systohc

if [ -x /sbin/halt.pre ]; then
   /sbin/halt.pre
fi

update_boot_stage umount

# Try to unmount tmpfs filesystems to avoid swapping them in.  Ignore failures.
tmpfs=$(awk '$2 ~ /^\/($|proc|dev)/ { next; }
	     $3 == "tmpfs" { print $2; }' /proc/mounts | sort -r)
[ -n "$tmpfs" ] && fstab-decode $UMOUNT $tmpfs 2>/dev/null

# Turn off swap, then unmount file systems.
[ -f /proc/swaps ] && SWAPS=`awk '! /^Filename/ { print $1 }' /proc/swaps`
if [ -n "$SWAPS" ]; then
    action "Turning off swap: " swapoff $SWAPS
    for dst in $SWAPS; do
	if [[ "$dst" =~ ^/dev/mapper ]] \
	    && [ "$(dmsetup status "$dst" | cut -d ' ' -f 3)" = crypt ]; then
	    backdev=$(/sbin/cryptsetup status "$dst" \
		| awk '$1 == "device:" { print $2 }')
	    /sbin/cryptsetup remove "$dst"
	fi
    done
fi

[ -x /sbin/quotaoff ] && action "Turning off quotas: " /sbin/quotaoff -aug

# first remove entry /initrd/loopfs as it can't be unmounted :(
mtab=$(fgrep -v "/initrd/loopfs[^/]" /etc/mtab)
(IFS= ; echo $mtab > /etc/mtab)

# Unmount file systems, killing processes if we have to.
# Unmount loopback stuff first
__umount_loopback_loop

# Unmount RPC pipe file systems
__umount_loop '$3 ~ /^rpc_pipefs$/ || $3 ~ /^rpc_svc_gss_pipefs$/ {print $2}' \
    /proc/mounts \
    "Unmounting pipe file systems: " \
    "Unmounting pipe file systems (retry): " \
    -f

LANG=C __umount_loop '$2 ~ /^\/$|^\/proc|^\/dev/{next}
	$2 ~ /^\/live\//{next}
	$3 == "tmpfs" || $3 == "proc" {print $2 ; next}
	/(loopfs|autofs|nfs|cifs|smbfs|ncpfs|sysfs|^none|^\/dev\/ram|^\/dev\/root$)/ {next}
	{print $2}' /proc/mounts \
	"Unmounting file systems: " \
	"Unmounting file systems (retry): " \
	-f


update_boot_stage lvm

if [ -f /etc/lvm/lvm.conf -a -x /sbin/lvm2 ]; then
	if grep -q -s 'device-mapper' /proc/devices; then
		_vgchange_cmd="/sbin/lvm2 vgchange -a n"
	fi
fi

if [ -z "${_vgscan_cmd}" -a -f /etc/lvmtab -a -e /proc/lvm ] ; then
	if [ -x /sbin/lvm1-vgchange ]; then
		_vgchange_cmd="/sbin/lvm1-vgchange -a n"
	elif [ -x /sbin/vgchange ]; then
		_vgchange_cmd="/sbin/vgchange -a n"
	fi
fi

if [ -n "${_vgchange_cmd}" ]; then
    action "Shutting down LVM:" ${_vgchange_cmd}
fi

# for NUT
# do it here to have /proc/usb mounted for UPS on USB
if [ -f /etc/init.d/upsd ]; then
    /etc/init.d/upsd powerdown
    [ $? == 3 ] && exit 1
fi

[ -f /proc/bus/usb/devices ] && $UMOUNT /proc/bus/usb

[ -f /etc/crypttab ] && halt_crypto

# remove the crash indicator flag
rm -f /.autofsck

update_boot_stage umount_force

# Try all file systems other than root, essential filesystems and RAM disks,
# one last time.
awk '$2 !~ /\/(|dev|proc|selinux|sys)$/ && $2 !~ /^\/live\// && $1 !~ /^\/dev\/ram/ { print $2 }' \
    /proc/mounts | sort -r | \
  while read line; do
    fstab-decode $UMOUNT -f $line
done

if [ -x /sbin/halt.local ]; then
   /sbin/halt.local
fi

update_boot_stage remount_ro

# Remount read only anything that's left mounted.
# gprintf "Remounting remaining filesystems readonly\n"
mount | awk '{ print $3 }' | while read line; do
    fstab-decode mount -n -o ro,remount $line
done

action "Unmounting proc file system: " umount /proc

# See if this is a powerfail situation.
if [ -f /etc/apcupsd/powerfail ]; then
  gprintf "APCUPSD will now power off the UPS!\n"
  echo
  /etc/apcupsd/apccontrol killpower
  echo
  gprintf "Please ensure that the UPS has powered off before rebooting\n"
  gprintf "Otherwise, the UPS may cut the power during the reboot!!!\n"
  echo
fi

update_boot_stage halt

# Now halt or reboot.
echo "$message"
if [ -f /fastboot ]; then
 gprintf "On the next boot fsck will be skipped.\n"
elif [ -f /forcefsck ]; then
 gprintf "On the next boot fsck will be forced.\n"
fi

# First, try kexec. If that fails, fall back to rebooting the old way.
[ -n "$kexec_command" ] && $kexec_command -e -x >& /dev/null

HALTARGS="-i -d"
[ "$INIT_HALT" != "HALT" ] && HALTARGS="$HALTARGS -p"

exec $command $HALTARGS
